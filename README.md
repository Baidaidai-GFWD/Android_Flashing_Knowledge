## 磁盘文件分区表
>	类似于mount后输出的内容,是又不完全是
>	因为mount是***已经挂载的文件系统列表***
>[相关链接](https://www.cnblogs.com/wkfvawl/p/11687619.html)**Java版**    ~~可能是分区管理？~~
>[修补链接](https://zhuanlan.zhihu.com/p/370552513#:~:text=硬盘分区表格式GUID和MBR知识普及%201%201.%20MBR分区表：Master%20Boot%20Record，即硬盘主引导记录分区表，只支持容量在%202.1TB,以下的硬盘，超过2.1TB的硬盘只能管理2.1TB，最多只支持4个主分区或三个主分区和一个扩展分区，扩展分区下可以有多个逻辑分区%E3%80%82%202%202.%20GPT分区表：GPT，全局唯一标识分区表%20%28GUID%20Partition%20Table%29，与MBR最大4个分区表项的限制相比，GPT对分区数量没有限制，但Windows最大仅支持128个GPT分区，GPT可管理硬盘大小达到了18EB%E3%80%82%20只有基于UEFI平台的主板才支持GPT分区引导启动%E3%80%82)**类原生**    ~~是真正的分区表~~
- 分区表是磁盘上的一张表，汇总描述了分区的大小和位置。它位于硬盘的首扇区(0柱面，0磁头，1扇区，MBR)
- 分区表一般有两种存储分区信息的方案，传统的MBR（Master Boot Record）分区表和GPT（GUID Partition Table）分区表，包括分区在物理磁盘上的起止位置
- 通过分区表允许你的操作系统知道哪些扇区属于哪个分区以及哪个分区是可引导的
- **MBR分区表：Master Boot Record，即硬盘主引导记录分区表，只支持容量在 2.1TB 以下的硬盘，超过2.1TB的硬盘只能管理2.1TB，最多只支持4个主分区或三个主分区和一个扩展分区，扩展分区下可以有多个逻辑分区**
- **GPT分区表：GPT，全局唯一标识分区表(GUID Partition Table)，与MBR最大4个分区表项的限制相比，GPT对分区数量没有限制，但Windows最大仅支持128个GPT分区，GPT可管理硬盘大小达到了18EB。只有基于UEFI平台的主板才支持GPT分区引导启动**
## 磁盘文件分区类型(~~分区格式~~)
1. FAT
		`最初是为软盘设计的文件系统`.
		**为什么只能存储4GB**：FAT文件系统使用32位文件大小字段来记录文件的大小，这意味着文件大小的最大限制为2^32-1个字节，约为4G`
1. ExtFAT
		`它是专门为闪存盘设计的文件系统，单个文件突破了4G的限制，而且分区的最大容量可达64ZB，建议512TB`
1. ext2
		`ext2是为解决ext文件系统的缺陷而设计的可扩展的、高性能的文件系统，又被称为二级扩展文件系统。它是Linux文件系统中使用最多的类型，并且在速度和CPU利用率上较为突出。ext2存取文件的性能极好，并可以支持256字节的长文件名，是GNU/Linux系统中标准的文件系统`
4. ext3
		`ext3是ext2文件系统的日志版本，它在ext2文件系统中增加了日志的功能。ext3提供了3种日志模式：日志（journal）、顺序（ordered）和回写（writeback）。与ext2相比，ext3提供了更好的安全性以及向上向下的兼容性能`
5. ext4
	1. 与 Ext3 兼容：执行若干条命令，能从 Ext3 在线迁移到Ext4，而无须重新格式化磁盘或重新安装系统
	2. 更大的文件系统和更大的文件。较之 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，Ext4分别支持 1EB（1,048,576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件
	3. 无限数量的子目录。Ext3 目前只支持 32,000 个子目录，而Ext4支持无限数量的子目录
	4. Ext4引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“该文件数据保存在接下来的 25,600 个数据块中”，提高了不少效率
	5. 当写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25,600 次数据块分配器，而Ext4的多块分配器“multiblock allocator”（mballoc） 支持一次调用分配多个数据块
	6. Ext4和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能
	7. 快速 fsck。以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，现在Ext4给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 inode 了
6. APFS
## super分区是什么?
>	super分区原理如下:
>		因为若存在(system|vendor|cust|product)分区,每次系统更新时,这些分区表都需要进行动态更新，会频造成繁擦写以及造成麻烦
>		与其这么麻烦地擦写，还不如直接mkdir一个文件夹(30GB(当然这是我瞎写的))这样就可以在有限的空间内随意排版，动态更新信息，而不用一直在外部分区表中动态更新这些分区，岂不美哉？
>		故，super分区称为：动态分区

![[super分区.jpeg]]
## /etc/fstab文件的作用
>	fstab用于提前挂载磁盘，且指定了磁盘的分区格式和挂载点
## 纯A分区｜A/B分区｜V A/B分区的概念
1. 纯A分区：
	>	包含了recovery和system分区，未对system、cust、vendor分区做Super大分区
2. 纯A动态分区：
	>	包含了recovery分区，但是对系统的system、cust、vendor分区做了Super大分区
3. 纯A/B分区：
	>	**A/B分区会将Recovery整合进Boot分区！**
	>	将系统分成了两个部分，A槽和B槽
	>	
	>	不使用B槽(B槽没系统)的时候，B槽为空。而一旦OTA或者动态升级的时候，用户空间A槽得以保留，并可以继续使用，OTA时会将新系统自动写入B槽，只需用户重启后即可切换到新系统B槽中
	>	
	>	而且即使B槽更新失败了，也可以直接通过退回A槽保持原系统，而不会丢失数据
	>	
	>	纯A/B分区不会将system、cust、vendor分区做Super大分区
4. 动态A/B分区：
>	字面意思
5. V A/B分区
>	**不可刷入不确定的DSU！！！
>	Virtual(虚拟) A/B分区，简称VA/B分区，结合了纯A和动态A/B的所有缺点于一身**
>	VA/B原理如下：
>		1.逻辑分区(system、vendor)虚拟出了一个B槽，但是**并未实体挂载**，而是虚拟了一个镜像位出来
>		2.当用户在进行OTA更新时，会将新下载的逻辑分区变成虚拟分区B槽。待重启后，将B槽的名称重命名为A槽，并将A槽删除
>		
>	VA/B分区和A/B分区都没有recovery，那如何进入呢：
>		答案就在VA/B分区和A/B分区的Boot.img里
>		直接使用`fastboot boot recovery.img`即可进入recovery，再在recovery里刷入TWRP即可替换原生recovery
>		绝对不可直接刷入`fastboot flash boot recovery.img`
>		绝对不可直接刷入`fastboot flash boot recovery.img`
>		绝对不可直接刷入`fastboot flash boot recovery.img`
>		
>![[vab.jpg]]
>
